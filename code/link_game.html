<!DOCTYPE html>
<meta charset="utf-8">
<style>

    circle {
      stroke-width: 1.5px;
    }

    line {
      stroke: #999;
    }

</style>
<body>

<div style="width: 100%; display: table;">
    <div style="
  border: 3px solid red;
  padding: 10px; overflow: ; display: table-row;">
        <div class="svg-container" style="
display: table-cell;
width: 75%;
  border: 3px solid blue;
  padding: 10px;">

        </div>
        <div style="
  border: 3px solid #73AD21;
  padding: 10px; display: table-cell;">

        </div>
    </div>
</div>

<script src="d3.js"></script>
<script>

    // inspirations :
    // Labeled Force Layout https://bl.ocks.org/mbostock/950642
    // Bounded Force Layout https://bl.ocks.org/mbostock/1129492
    // Modifying a Force Layout https://bl.ocks.org/mbostock/1095795

    dict_nodes = {
        "perso_war": ["Guerrier", ],
        "perso_mag": ["Mage", ],
        "obj_longsword": ["Épée longue", ],
        "obj_mage_scroll": ["Sorts de mage", ],
        "obj_mage_book": ["Livre de sorts", ],
    }

    // C'est un peu dégueux, parce qu'on se retrouve avec les données en triple,
    // dans dict_nodes, dict_nodes_processed et init_nodes. Eh bien voilà, pas mieux.
    dict_nodes_processed = {}

    init_nodes = []

    for (var key in dict_nodes) {
        var name = dict_nodes[key][0]
        new_node = { "node_id": key, "name": name }
        init_nodes.push(new_node)
        dict_nodes_processed[key] = new_node
    }

    answers = [
        ["perso_war", "obj_longsword", false],
        ["perso_mag", "obj_mage_scroll", false],
        ["perso_war", "obj_mage_scroll", false],
        ["perso_mag", "obj_mage_book", false],
        ["perso_war", "obj_mage_book", false],
    ]

    first_selection = null;
    second_selection = null;

    function init_force_layout() {

        graph = {
            "nodes": init_nodes,
            "links": [],
        }

        // http://www.sebarmeli.com/blog/2010/12/06/best-way-to-loop-through-an-array-in-javascript/
        // https://stackoverflow.com/questions/3010840/loop-through-an-array-in-javascript#3010848
        // C'est une blague ? Il faut lire deux articles et envisager 6 façons de faire pour boucler sur un tableau ?
        // C'est quoi ce langage ?
        for (var answer of answers) {
            if (answer[2]) {
                graph["links"].push({source: dict_nodes_processed[answer[0]], target: dict_nodes_processed[answer[1]], value: 1})
            }
        }

        width = 960
        height = 500
        radius = 6

        var fill = d3.scale.category20()

        var force = d3.layout.force()
            .gravity(.05)
            .charge(-240)
            .linkDistance(50)
            .size([width, height])
            //.size(["100%", height])

        var svg = d3.select(".svg-container").append("svg")
            //.attr("width", width)
            //.attr("height", height)
            .attr("viewBox", "0 0 " + width + " " + height )
            .attr("style", "width: 100%; background-color: lightgray;")

        link = svg.selectAll("line")
            .data(graph.links)
            .enter().append("line")

        node = svg.selectAll("circle")
            .data(graph.nodes)
            .enter().append("g")
            .attr("name", function(d) { return d.name })
            .attr("node_id", function(d) { return d.node_id })
            .call(force.drag)

        node.append("image")
            .attr("xlink:href", "silver_key.png")
            .attr("x", -8)
            .attr("y", -8)
            .attr("width", 16)
            .attr("height", 16)

        node.append("text")
            .attr("dx", 12)
            .attr("dy", ".35em")
            .text(function(d) { return d.name })

        force.nodes(graph.nodes)
            .links(graph.links)
            .on("tick", tick)
            .start()


        node.on("click", function() {

            if (first_selection == null) {
                first_selection = d3.select(this).attr('node_id')
                console.log("first selection " + first_selection)
            }
            else {
                second_selection = d3.select(this).attr('node_id')
                console.log("first selection " + first_selection)
                console.log("second selection " + second_selection)

                var must_refresh = false

                for (var answer of answers) {
                    if ((answer[2] == false) && (
                        ((answer[0] == first_selection) && (answer[1] == second_selection)) || ((answer[1] == first_selection) && (answer[0] == second_selection))
                    )) {
                        answer[2] = true
                        must_refresh = true
                    }
                }

                if (must_refresh) {
                    d3.select("svg").remove()
                    // Donc là, on repète tout le graphe pour le reconstruire de zéro. C'est méga-bourrin, mais apparamment ça marche.
                    init_force_layout()
                }

                first_selection = null
            }
        })

    }

    function tick() {
        node.attr("cx", function(d) { return d.x = Math.max(radius, Math.min(width - radius, d.x)) })
            .attr("cy", function(d) { return d.y = Math.max(radius, Math.min(height - radius, d.y)) })

        link.attr("x1", function(d) { return d.source.x })
            .attr("y1", function(d) { return d.source.y })
            .attr("x2", function(d) { return d.target.x })
            .attr("y2", function(d) { return d.target.y })

        node.attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")" })
    }

    init_force_layout()

</script>
</body>